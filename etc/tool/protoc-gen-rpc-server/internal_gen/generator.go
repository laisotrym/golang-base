package internal_gen

import (
	"fmt"
	"strconv"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var packages = map[string]string{
	"fmt":      "fmt",
	"context":  "context",
	"net":      "net",
	"grpc":     "google.golang.org/grpc",
	"runtime":  "github.com/grpc-ecosystem/grpc-gateway/runtime",
	"http":     "net/http",
	"os":       "os",
	"log":      "log",
	"signal":   "os/signal",
	"time":     "time",
	"syscall":  "syscall",
	"grpcprom": "github.com/grpc-ecosystem/go-grpc-prometheus",
	"promhttp": "github.com/prometheus/client_golang/prometheus/promhttp",
	"gwopt":    "jupiter.app/grpc/gatewayopt",
}

func pkg(name string) protogen.GoImportPath {
	if path, ok := packages[name]; ok {
		return protogen.GoImportPath(path)
	}
	panic(fmt.Sprintf("Cannot find package %s!", name))
}

func id(packageName string, identName string) protogen.GoIdent {
	return pkg(packageName).Ident(identName)
}

func GenerateFile(p *protogen.Plugin, importPath protogen.GoImportPath, gatewayEnabled bool, gatewayOptions []string, g *protogen.GeneratedFile) error {
	genHeader(p, g)
	genPackage(importPath, g)
	genTypes(gatewayEnabled, g)
	return genServer(p, importPath, gatewayEnabled, gatewayOptions, g)
}

func genHeader(p *protogen.Plugin, g *protogen.GeneratedFile) {
	p.Request.GetCompilerVersion().String()

	v := p.Request.GetCompilerVersion()
	g.P(fmt.Sprintf(`
	// Code generated by protoc-gen-go. DO NOT EDIT.
	// versions:
	//   protoc %d.%d.%d
	// sources:`, *v.Major, *v.Minor, *v.Patch))
	for _, file := range p.Request.GetFileToGenerate() {
		g.P("//   ", file)
	}
	g.P()
}

func genPackage(importPath protogen.GoImportPath, g *protogen.GeneratedFile) {
	importPathArray := strings.Split(string(importPath), "/")
	g.P("package ", importPathArray[len(importPathArray)-1])
	g.P()
}

func genTypes(gatewayEnabled bool, g *protogen.GeneratedFile) {

	g.P(`// DefaultConfig return a default server config
	func DefaultConfig() Config {
		return Config{
			GRPC: ServerListen {
				Host: "0.0.0.0",
				Port: 10443,
			},
			HTTP: ServerListen {
				Host: "0.0.0.0",
				Port: 10080,
			},
		}
	}`)

	g.P("// Config hold http/grpc server config")
	g.P("type Config struct {")
	g.P("GRPC ServerListen", "`json:\"grpc\" mapstructure:\"grpc\" yaml:\"grpc\"`")
	g.P("HTTP ServerListen", "`json:\"http\" mapstructure:\"http\" yaml:\"http\"`")
	g.P("}")
	g.P()

	g.P("// ServerListen config for host/port socket listener")
	g.P("type ServerListen struct {")
	g.P("Host string", "`json:\"host\" mapstructure:\"host\" yaml:\"host\"`")
	g.P("Port int", "`json:\"port\" mapstructure:\"port\" yaml:\"port\"`")
	g.P("}")
	g.P()

	g.P("// String return socket listen DSN")
	g.P("func (l ServerListen) String() string {")
	g.P("return ", id("fmt", "Sprintf("), strconv.Quote("%s:%d"), ",l.Host, l.Port)")
	g.P("}")
	g.P()

	g.P("// Server structure")
	g.P("type Server struct {")
	g.P("gRPC *", id("grpc", "Server"))
	if gatewayEnabled {
		g.P("mux *", id("runtime", "ServeMux"))
	}
	g.P("cfg Config")
	g.P("}")
	g.P()
	g.P()
}

func genServer(p *protogen.Plugin, ip protogen.GoImportPath, gatewayEnabled bool, gatewayOptions []string, g *protogen.GeneratedFile) error {

	// Generate New Server
	g.P("func NewServer(cfg Config, opt ...", id("grpc", "ServerOption"), ") *", ip.Ident("Server"), "{")
	g.P("return &", ip.Ident("Server"), "{")
	g.P("gRPC: ", id("grpc", "NewServer("), "opt...), ")
	if gatewayEnabled {

		g.P("mux: ", id("runtime", "NewServeMux"), "(")
		for _, opt := range gatewayOptions {
			g.P(id("gwopt", opt), "(),")
		}
		g.P("),")
	}
	g.P("cfg: cfg,")
	g.P("}")
	g.P("}")
	g.P()

	// Generate Register GrpcService

	g.P("func (s *", ip.Ident("Server"), ") Register(grpcServer ...interface{}) error {")

	g.P("for _, srv := range grpcServer {")
	g.P("switch _srv := srv.(type) {")

	for _, f := range p.Files {
		for _, s := range f.Services {
			g.P("case ", f.GoImportPath.Ident(s.GoName), "Server:")
			g.P(f.GoImportPath.Ident("Register"+s.GoName), "Server(s.gRPC, _srv)")

			if gatewayEnabled {

				hasHttpAnnotations := false

				for _, m := range s.Methods {
					op := m.Desc.Options().(proto.Message)
					if proto.HasExtension(op, annotations.E_Http) {
						hasHttpAnnotations = true
					}
				}

				if hasHttpAnnotations {
					g.P("if err := ", f.GoImportPath.Ident("Register"+s.GoName), "HandlerFromEndpoint(", id("context", "Background"), "(), s.mux, s.cfg.GRPC.String(), []grpc.DialOption{grpc.WithInsecure()}); err != nil {")
					g.P("return err}")
				}
			}
			// end of gateway enabled
		}
	}

	g.P("default:")
	g.P("return ", id("fmt", "Errorf"), "(\"Unknown GRPC Service to register %#v\", srv)")
	g.P("}")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()
	g.P("func isRunningInDockerContainer() bool {")
	g.P("	if _, err := os.Stat(\"/.dockerenv\"); err == nil {")
	g.P("		return true")
	g.P("	}")
	g.P("	return false")
	g.P("}")
	g.P()

	g.P("// Serve server listen for HTTP and GRPC")
	g.P("func (s *Server) Serve() error {")
	g.P("stop := make(chan ", id("os", "Signal"), ", 1)")
	g.P("errch := make(chan error)")
	g.P(id("signal", "Notify(stop, "), id("os", "Interrupt, "), id("syscall", "SIGINT,"), id("syscall", "SIGTERM"), ")")

	g.P("httpMux := ", id("http", "NewServeMux()"))
	g.P("httpMux.Handle(", strconv.Quote("/metrics"), ",", id("promhttp", "Handler())"))
	if gatewayEnabled {
		g.P("httpMux.Handle(", strconv.Quote("/"), ",s.mux)")
	}

	g.P("httpServer := ", id("http", "Server{"))
	g.P("Addr: s.cfg.HTTP.String(),")
	g.P("Handler: httpMux,")
	g.P("}")

	g.P("go func() {")

	g.P("if err := httpServer.ListenAndServe(); err != nil {")
	g.P("errch <- err")
	g.P("}}()")

	g.P("go func() {")
	g.P("listener, err := ", id("net", "Listen"), "(", strconv.Quote("tcp"), ", s.cfg.GRPC.String())")
	g.P("if err != nil { errch <- err; return }")

	g.P("if err := s.gRPC.Serve(listener); err != nil {")
	g.P("errch <- err")
	g.P("}}()")

	g.P("for {")
	g.P("select {")
	g.P("case <-stop:")
	g.P("ctx, cancel := ", id("context", "WithTimeout(context.Background(), 30*"), id("time", "Second)"))
	g.P("defer cancel()")
	g.P("s.gRPC.GracefulStop()")
	g.P("httpServer.Shutdown(ctx)")
	g.P("if !isRunningInDockerContainer() {")
	g.P("fmt.Println(\"Shutting down. Wait for 15 seconds\")")
	g.P("time.Sleep(15 * time.Second)")
	g.P("}")
	g.P("return nil")
	g.P("case err := <-errch:")
	g.P("return err")
	g.P("}}}")

	return nil
}
